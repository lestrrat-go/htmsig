package htmsig_test

import (
	"context"
	"crypto/ecdsa"
	"crypto/ed25519"
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64"
	"encoding/pem"
	"fmt"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/lestrrat-go/htmsig"
	"github.com/lestrrat-go/htmsig/component"
	"github.com/lestrrat-go/htmsig/input"
	"github.com/stretchr/testify/require"
)

// Test vectors from RFC 9421 Appendix B
// All keys and test data are from the RFC examples and MUST NOT be used in production

// Example keys from B.1
const (
	// B.1.1 RSA Key (test-key-rsa) - 2048-bit RSA key pair
	testKeyRSAPublicPEM = `-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEAhAKYdtoeoy8zcAcR874L8cnZxKzAGwd7v36APp7Pv6Q2jdsPBRrw
WEBnez6d0UDKDwGbc6nxfEXAy5mbhgajzrw3MOEt8uA5txSKobBpKDeBLOsdJKFq
MGmXCQvEG7YemcxDTRPxAleIAgYYRjTSd/QBwVW9OwNFhekro3RtlinV0a75jfZg
kne/YiktSvLG34lw2zqXBDTC5NHROUqGTlML4PlNZS5Ri2U4aCNx2rUPRcKIlE0P
uKxI4T+HIaFpv8+rdV6eUgOrB2xeI1dSFFn/nnv5OoZJEIB+VmuKn3DCUcCZSFlQ
PSXSfBDiUGhwOw76WuSSsf1D4b/vLoJ10wIDAQAB
-----END RSA PUBLIC KEY-----`

	testKeyRSAPrivatePEM = `-----BEGIN RSA PRIVATE KEY-----
MIIEqAIBAAKCAQEAhAKYdtoeoy8zcAcR874L8cnZxKzAGwd7v36APp7Pv6Q2jdsP
BRrwWEBnez6d0UDKDwGbc6nxfEXAy5mbhgajzrw3MOEt8uA5txSKobBpKDeBLOsd
JKFqMGmXCQvEG7YemcxDTRPxAleIAgYYRjTSd/QBwVW9OwNFhekro3RtlinV0a75
jfZgkne/YiktSvLG34lw2zqXBDTC5NHROUqGTlML4PlNZS5Ri2U4aCNx2rUPRcKI
lE0PuKxI4T+HIaFpv8+rdV6eUgOrB2xeI1dSFFn/nnv5OoZJEIB+VmuKn3DCUcCZ
SFlQPSXSfBDiUGhwOw76WuSSsf1D4b/vLoJ10wIDAQABAoIBAG/JZuSWdoVHbi56
vjgCgkjg3lkO1KrO3nrdm6nrgA9P9qaPjxuKoWaKO1cBQlE1pSWp/cKncYgD5WxE
CpAnRUXG2pG4zdkzCYzAh1i+c34L6oZoHsirK6oNcEnHveydfzJL5934egm6p8DW
+m1RQ70yUt4uRc0YSor+q1LGJvGQHReF0WmJBZHrhz5e63Pq7lE0gIwuBqL8SMaA
yRXtK+JGxZpImTq+NHvEWWCu09SCq0r838ceQI55SvzmTkwqtC+8AT2zFviMZkKR
Qo6SPsrqItxZWRty2izawTF0Bf5S2VAx7O+6t3wBsQ1sLptoSgX3QblELY5asI0J
YFz7LJECgYkAsqeUJmqXE3LP8tYoIjMIAKiTm9o6psPlc8CrLI9CH0UbuaA2JCOM
cCNq8SyYbTqgnWlB9ZfcAm/cFpA8tYci9m5vYK8HNxQr+8FS3Qo8N9RJ8d0U5Csw
DzMYfRghAfUGwmlWj5hp1pQzAuhwbOXFtxKHVsMPhz1IBtF9Y8jvgqgYHLbmyiu1
mwJ5AL0pYF0G7x81prlARURwHo0Yf52kEw1dxpx+JXER7hQRWQki5/NsUEtv+8RT
qn2m6qte5DXLyn83b1qRscSdnCCwKtKWUug5q2ZbwVOCJCtmRwmnP131lWRYfj67
B/xJ1ZA6X3GEf4sNReNAtaucPEelgR2nsN0gKQKBiGoqHWbK1qYvBxX2X3kbPDkv
9C+celgZd2PW7aGYLCHq7nPbmfDV0yHcWjOhXZ8jRMjmANVR/eLQ2EfsRLdW69bn
f3ZD7JS1fwGnO3exGmHO3HZG+6AvberKYVYNHahNFEw5TsAcQWDLRpkGybBcxqZo
81YCqlqidwfeO5YtlO7etx1xLyqa2NsCeG9A86UjG+aeNnXEIDk1PDK+EuiThIUa
/2IxKzJKWl1BKr2d4xAfR0ZnEYuRrbeDQYgTImOlfW6/GuYIxKYgEKCFHFqJATAG
IxHrq1PDOiSwXd2GmVVYyEmhZnbcp8CxaEMQoevxAta0ssMK3w6UsDtvUvYvF22m
qQKBiD5GwESzsFPy3Ga0MvZpn3D6EJQLgsnrtUPZx+z2Ep2x0xc5orneB5fGyF1P
WtP+fG5Q6Dpdz3LRfm+KwBCWFKQjg7uTxcjerhBWEYPmEMKYwTJF5PBG9/ddvHLQ
EQeNC8fHGg4UXU8mhHnSBt3EA10qQJfRDs15M38eG2cYwB1PZpDHScDnDA0=
-----END RSA PRIVATE KEY-----`

	// B.1.3 ECC P-256 Key (test-key-ecc-p256) - P-256 elliptic curve key pair
	testKeyECCP256PublicPEM = `-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEqIVYZVLCrPZHGHjP17CTW0/+D9Lf
w0EkjqF7xB4FivAxzic30tMM4GF+hR6Dxh71Z50VGGdldkkDXZCnTNnoXQ==
-----END PUBLIC KEY-----`

	testKeyECCP256PrivatePEM = `-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIFKbhfNZfpDsW43+0+JjUr9K+bTeuxopu653+hBaXGA7oAoGCCqGSM49
AwEHoUQDQgAEqIVYZVLCrPZHGHjP17CTW0/+D9Lfw0EkjqF7xB4FivAxzic30tMM
4GF+hR6Dxh71Z50VGGdldkkDXZCnTNnoXQ==
-----END EC PRIVATE KEY-----`

	// B.1.4 Ed25519 Key (test-key-ed25519) - Ed25519 elliptic curve key
	testKeyEd25519PublicPEM = `-----BEGIN PUBLIC KEY-----
MCowBQYDK2VwAyEAJrQLj5P/89iXES9+vFgrIy29clF9CC/oPPsw3c5D0bs=
-----END PUBLIC KEY-----`

	testKeyEd25519PrivatePEM = `-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEIJ+DYvh6SEqVTm50DFtMDoQikTmiCqirVv9mWG9qfSnF
-----END PRIVATE KEY-----`

	// B.1.5 Shared Secret (test-shared-secret) - 64 randomly generated bytes
	testSharedSecretB64 = `uzvJfB4u3N0Jy4T7NZ75MDVcr8zSTInedJtkgcu46YW4XByzNJjxBdtjUkdJPBtbmHhIDi6pcl8jsasjlTMtDQ==`
)

// Base HTTP messages from RFC examples - with line wrapping removed
var (
	// Test request message from B.2
	testRequestBody = `{"hello": "world"}`

	testRequestContentDigest = `sha-512=:WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+AbwAgBWnrIiYllu7BNNyealdVLvRwEmTHWXvJwew==:`

	testResponseContentDigest = `sha-512=:mEWXIS7MaLRuGgxOBdODa3xqM1XdEvxoYhvlCFJ41QJgJc4GTsPp29l5oGX69wWdXymyU0rjJuahq4l5aGgfLQ==:`
)

// createTestRequest creates the standard test request from RFC examples
func createTestRequest() *http.Request {
	req := httptest.NewRequest("POST", "https://example.com/foo?param=Value&Pet=dog", strings.NewReader(testRequestBody))
	req.Header.Set("Host", "example.com")
	req.Header.Set("Date", "Tue, 20 Apr 2021 02:07:55 GMT")
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Content-Digest", testRequestContentDigest)
	req.Header.Set("Content-Length", "18")
	return req
}

// createTestResponse creates the standard test response from RFC examples
func createTestResponse(req *http.Request) *http.Response {
	resp := &http.Response{
		StatusCode: 200,
		Status:     "200 OK",
		Proto:      "HTTP/1.1",
		ProtoMajor: 1,
		ProtoMinor: 1,
		Header:     make(http.Header),
		Request:    req,
	}
	resp.Header.Set("Date", "Tue, 20 Apr 2021 02:07:56 GMT")
	resp.Header.Set("Content-Type", "application/json")
	resp.Header.Set("Content-Digest", testResponseContentDigest)
	resp.Header.Set("Content-Length", "23")
	return resp
}

// parsePrivateKey parses a PEM private key and returns the appropriate type
func parsePrivateKey(pemData string, keyType string) (any, error) {
	block, _ := pem.Decode([]byte(pemData))
	if block == nil {
		return nil, fmt.Errorf("failed to decode PEM block")
	}

	switch keyType {
	case "rsa", "rsa-pss":
		key, err := x509.ParsePKCS1PrivateKey(block.Bytes)
		if err != nil {
			// Try PKCS8 format
			keyIface, err := x509.ParsePKCS8PrivateKey(block.Bytes)
			if err != nil {
				return nil, fmt.Errorf("failed to parse RSA private key: %w", err)
			}
			rsaKey, ok := keyIface.(*rsa.PrivateKey)
			if !ok {
				return nil, fmt.Errorf("expected RSA private key, got %T", keyIface)
			}
			return rsaKey, nil
		}
		return key, nil
	case "ecdsa":
		key, err := x509.ParseECPrivateKey(block.Bytes)
		if err != nil {
			// Try PKCS8 format
			keyIface, err := x509.ParsePKCS8PrivateKey(block.Bytes)
			if err != nil {
				return nil, fmt.Errorf("failed to parse ECDSA private key: %w", err)
			}
			ecKey, ok := keyIface.(*ecdsa.PrivateKey)
			if !ok {
				return nil, fmt.Errorf("expected ECDSA private key, got %T", keyIface)
			}
			return ecKey, nil
		}
		return key, nil
	case "ed25519":
		keyIface, err := x509.ParsePKCS8PrivateKey(block.Bytes)
		if err != nil {
			return nil, fmt.Errorf("failed to parse Ed25519 private key: %w", err)
		}
		edKey, ok := keyIface.(ed25519.PrivateKey)
		if !ok {
			return nil, fmt.Errorf("expected Ed25519 private key, got %T", keyIface)
		}
		return edKey, nil
	default:
		return nil, fmt.Errorf("unsupported key type: %s", keyType)
	}
}

// parsePublicKey parses a PEM public key and returns the appropriate type
func parsePublicKey(pemData string, keyType string) (any, error) {
	block, _ := pem.Decode([]byte(pemData))
	if block == nil {
		return nil, fmt.Errorf("failed to decode PEM block")
	}

	switch keyType {
	case "rsa", "rsa-pss":
		key, err := x509.ParsePKCS1PublicKey(block.Bytes)
		if err != nil {
			// Try PKIX format
			keyIface, err := x509.ParsePKIXPublicKey(block.Bytes)
			if err != nil {
				return nil, fmt.Errorf("failed to parse RSA public key: %w", err)
			}
			rsaKey, ok := keyIface.(*rsa.PublicKey)
			if !ok {
				return nil, fmt.Errorf("expected RSA public key, got %T", keyIface)
			}
			return rsaKey, nil
		}
		return key, nil
	case "ecdsa":
		keyIface, err := x509.ParsePKIXPublicKey(block.Bytes)
		if err != nil {
			return nil, fmt.Errorf("failed to parse ECDSA public key: %w", err)
		}
		ecKey, ok := keyIface.(*ecdsa.PublicKey)
		if !ok {
			return nil, fmt.Errorf("expected ECDSA public key, got %T", keyIface)
		}
		return ecKey, nil
	case "ed25519":
		keyIface, err := x509.ParsePKIXPublicKey(block.Bytes)
		if err != nil {
			return nil, fmt.Errorf("failed to parse Ed25519 public key: %w", err)
		}
		edKey, ok := keyIface.(ed25519.PublicKey)
		if !ok {
			return nil, fmt.Errorf("expected Ed25519 public key, got %T", keyIface)
		}
		return edKey, nil
	default:
		return nil, fmt.Errorf("unsupported key type: %s", keyType)
	}
}

// Test cases from RFC 9421 Appendix B.2

func TestRFC9421_B_2_1_MinimalSignature(t *testing.T) {
	// B.2.1 Minimal Signature Using rsa-pss-sha512
	req := createTestRequest()

	// For now, use the standard RSA key since JWX may not support RSA-PSS PKCS#8 format
	privKey, err := parsePrivateKey(testKeyRSAPrivatePEM, "rsa")
	require.NoError(t, err)

	// Parse the test RSA public key for verification
	pubKey, err := parsePublicKey(testKeyRSAPublicPEM, "rsa")
	require.NoError(t, err)

	// Create signature input - minimal signature with no covered components
	created := int64(1618884473)
	nonce := "b3k2pp5k7z-50gnwp.yemd"
	keyID := "test-key-rsa-pss"

	def := input.NewDefinitionBuilder().
		Label("sig-b21").
		Created(created).
		KeyID(keyID).
		Nonce(nonce).
		// Don't set algorithm explicitly to match RFC example output
		Components(). // Empty components for minimal signature
		MustBuild()

	inputValue := input.NewValueBuilder().AddDefinition(def).MustBuild()

	// Sign the request
	ctx := component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.SignRequest(ctx, req.Header, inputValue, privKey)
	require.NoError(t, err)

	// Verify expected signature headers exist
	require.NotEmpty(t, req.Header.Get("Signature-Input"))
	require.NotEmpty(t, req.Header.Get("Signature"))

	// Expected signature input (with RFC 8792 line wrapping removed)
	expectedSigInput := `sig-b21=();created=1618884473;keyid="test-key-rsa-pss";nonce="b3k2pp5k7z-50gnwp.yemd"`
	require.Equal(t, expectedSigInput, req.Header.Get("Signature-Input"))

	// Verify the signature
	ctx = component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.VerifyRequest(ctx, req.Header, pubKey)
	require.NoError(t, err)

	// Verify signature base generation produces expected result
	// Expected signature base from RFC:
	// `"@signature-params": ();created=1618884473;keyid="test-key-rsa-pss";nonce="b3k2pp5k7z-50gnwp.yemd"`

	// We can't easily access buildSignatureBase directly, but we can verify the signature works
	t.Logf("Minimal signature test passed - signature input: %s", req.Header.Get("Signature-Input"))
}

func TestRFC9421_B_2_2_SelectiveCoverage(t *testing.T) {
	// B.2.2 Selective Covered Components Using rsa-pss-sha512
	req := createTestRequest()

	// Use standard RSA key since JWX may not support RSA-PSS PKCS#8 format
	privKey, err := parsePrivateKey(testKeyRSAPrivatePEM, "rsa")
	require.NoError(t, err)

	pubKey, err := parsePublicKey(testKeyRSAPublicPEM, "rsa")
	require.NoError(t, err)

	// Create signature covering selective components
	created := int64(1618884473)
	keyID := "test-key-rsa-pss"
	tag := "header-example"

	def := input.NewDefinitionBuilder().
		Label("sig-b22").
		Components(
			component.Authority(),
			component.New("content-digest"),
			component.QueryParam().WithParameter("name", "Pet"),
		).
		Created(created).
		KeyID(keyID).
		Tag(tag).
		// Don't set algorithm explicitly to match RFC example output
		MustBuild()

	inputValue := input.NewValueBuilder().AddDefinition(def).MustBuild()

	// Sign the request
	ctx := component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.SignRequest(ctx, req.Header, inputValue, privKey)
	require.NoError(t, err)

	// Expected signature input (with line wrapping removed)
	expectedSigInput := `sig-b22=("@authority" "content-digest" "@query-param";name="Pet");created=1618884473;keyid="test-key-rsa-pss";tag="header-example"`
	require.Equal(t, expectedSigInput, req.Header.Get("Signature-Input"))

	// Verify the signature
	ctx = component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.VerifyRequest(ctx, req.Header, pubKey)
	require.NoError(t, err)

	t.Logf("Selective coverage test passed - signature input: %s", req.Header.Get("Signature-Input"))
}

func TestRFC9421_B_2_3_FullCoverage(t *testing.T) {
	// B.2.3 Full Coverage Using rsa-pss-sha512
	req := createTestRequest()

	// Use standard RSA key since JWX may not support RSA-PSS PKCS#8 format
	privKey, err := parsePrivateKey(testKeyRSAPrivatePEM, "rsa")
	require.NoError(t, err)

	pubKey, err := parsePublicKey(testKeyRSAPublicPEM, "rsa")
	require.NoError(t, err)

	// Create signature covering all standard components
	created := int64(1618884473)
	keyID := "test-key-rsa-pss"

	def := input.NewDefinitionBuilder().
		Label("sig-b23").
		Components(
			component.New("date"),
			component.Method(),
			component.New("@path"),
			component.New("@query"),
			component.Authority(),
			component.New("content-type"),
			component.New("content-digest"),
			component.New("content-length"),
		).
		Created(created).
		KeyID(keyID).
		// Don't set algorithm explicitly to match RFC example output
		MustBuild()

	inputValue := input.NewValueBuilder().AddDefinition(def).MustBuild()

	// Sign the request
	ctx := component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.SignRequest(ctx, req.Header, inputValue, privKey)
	require.NoError(t, err)

	// Expected signature input (with line wrapping removed)
	expectedSigInput := `sig-b23=("date" "@method" "@path" "@query" "@authority" "content-type" "content-digest" "content-length");created=1618884473;keyid="test-key-rsa-pss"`
	require.Equal(t, expectedSigInput, req.Header.Get("Signature-Input"))

	// Verify the signature
	ctx = component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.VerifyRequest(ctx, req.Header, pubKey)
	require.NoError(t, err)

	t.Logf("Full coverage test passed - signature input: %s", req.Header.Get("Signature-Input"))
}

func TestRFC9421_B_2_4_ResponseSignature(t *testing.T) {
	// B.2.4 Signing a Response Using ecdsa-p256-sha256
	req := createTestRequest()
	resp := createTestResponse(req)

	privKey, err := parsePrivateKey(testKeyECCP256PrivatePEM, "ecdsa")
	require.NoError(t, err)

	pubKey, err := parsePublicKey(testKeyECCP256PublicPEM, "ecdsa")
	require.NoError(t, err)

	// Create signature for response
	created := int64(1618884473)
	keyID := "test-key-ecc-p256"

	def := input.NewDefinitionBuilder().
		Label("sig-b24").
		Components(
			component.Status(),
			component.New("content-type"),
			component.New("content-digest"),
			component.New("content-length"),
		).
		Created(created).
		KeyID(keyID).
		// Don't set algorithm explicitly to match RFC example output
		MustBuild()

	inputValue := input.NewValueBuilder().AddDefinition(def).MustBuild()

	// Sign the response
	ctx := component.WithResponseInfoFromHTTP(context.Background(), resp)
	err = htmsig.SignResponse(ctx, resp.Header, inputValue, privKey)
	require.NoError(t, err)

	// Expected signature input (with line wrapping removed)
	expectedSigInput := `sig-b24=("@status" "content-type" "content-digest" "content-length");created=1618884473;keyid="test-key-ecc-p256"`
	require.Equal(t, expectedSigInput, resp.Header.Get("Signature-Input"))

	// Verify the signature
	ctx = component.WithResponseInfoFromHTTP(context.Background(), resp)
	err = htmsig.VerifyResponse(ctx, resp.Header, pubKey)
	require.NoError(t, err)

	t.Logf("Response signature test passed - signature input: %s", resp.Header.Get("Signature-Input"))
}

func TestRFC9421_B_2_5_HMACSignature(t *testing.T) {
	// B.2.5 Signing a Request Using hmac-sha256
	req := createTestRequest()

	// Decode the shared secret
	sharedSecret, err := base64.StdEncoding.DecodeString(testSharedSecretB64)
	require.NoError(t, err)

	// Create HMAC signature
	created := int64(1618884473)
	keyID := "test-shared-secret"

	def := input.NewDefinitionBuilder().
		Label("sig-b25").
		Components(
			component.New("date"),
			component.Authority(),
			component.New("content-type"),
		).
		Created(created).
		KeyID(keyID).
		// Don't set algorithm explicitly to match RFC example output
		MustBuild()

	inputValue := input.NewValueBuilder().AddDefinition(def).MustBuild()

	// Sign the request
	ctx := component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.SignRequest(ctx, req.Header, inputValue, sharedSecret)
	require.NoError(t, err)

	// Expected signature input (with line wrapping removed)
	expectedSigInput := `sig-b25=("date" "@authority" "content-type");created=1618884473;keyid="test-shared-secret"`
	require.Equal(t, expectedSigInput, req.Header.Get("Signature-Input"))

	// Verify the signature
	ctx = component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.VerifyRequest(ctx, req.Header, sharedSecret)
	require.NoError(t, err)

	t.Logf("HMAC signature test passed - signature input: %s", req.Header.Get("Signature-Input"))
}

func TestRFC9421_B_2_6_Ed25519Signature(t *testing.T) {
	// B.2.6 Signing a Request Using ed25519
	req := createTestRequest()

	privKey, err := parsePrivateKey(testKeyEd25519PrivatePEM, "ed25519")
	require.NoError(t, err)

	pubKey, err := parsePublicKey(testKeyEd25519PublicPEM, "ed25519")
	require.NoError(t, err)

	// Create Ed25519 signature
	created := int64(1618884473)
	keyID := "test-key-ed25519"

	def := input.NewDefinitionBuilder().
		Label("sig-b26").
		Components(
			component.New("date"),
			component.Method(),
			component.New("@path"),
			component.Authority(),
			component.New("content-type"),
			component.New("content-length"),
		).
		Created(created).
		KeyID(keyID).
		// Don't set algorithm explicitly to match RFC example output
		MustBuild()

	inputValue := input.NewValueBuilder().AddDefinition(def).MustBuild()

	// Sign the request
	ctx := component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.SignRequest(ctx, req.Header, inputValue, privKey)
	require.NoError(t, err)

	// Expected signature input (with line wrapping removed)
	expectedSigInput := `sig-b26=("date" "@method" "@path" "@authority" "content-type" "content-length");created=1618884473;keyid="test-key-ed25519"`
	require.Equal(t, expectedSigInput, req.Header.Get("Signature-Input"))

	// Verify the signature
	ctx = component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.VerifyRequest(ctx, req.Header, pubKey)
	require.NoError(t, err)

	t.Logf("Ed25519 signature test passed - signature input: %s", req.Header.Get("Signature-Input"))
}

// Test key resolver for multi-key scenarios
type testKeyResolver struct {
	keys map[string]any
}

func (r *testKeyResolver) ResolveKey(keyID string) (any, error) {
	key, exists := r.keys[keyID]
	if !exists {
		return nil, nil
	}
	return key, nil
}

func TestRFC9421_MultipleSignatures(t *testing.T) {
	// Test multiple signatures on the same request using different algorithms
	req := createTestRequest()

	// Parse all test keys - use standard RSA key since JWX may not support RSA-PSS PKCS#8 format
	rsaPSSPrivKey, err := parsePrivateKey(testKeyRSAPrivatePEM, "rsa")
	require.NoError(t, err)

	ecdsaPrivKey, err := parsePrivateKey(testKeyECCP256PrivatePEM, "ecdsa")
	require.NoError(t, err)

	ed25519PrivKey, err := parsePrivateKey(testKeyEd25519PrivatePEM, "ed25519")
	require.NoError(t, err)

	sharedSecret, err := base64.StdEncoding.DecodeString(testSharedSecretB64)
	require.NoError(t, err)

	// Create multiple signature definitions
	created := time.Now().Unix()

	rsaDef := input.NewDefinitionBuilder().
		Label("sig-rsa").
		Components(component.Method(), component.Authority()).
		Created(created).
		KeyID("test-key-rsa-pss").
		Algorithm("rsa-pss-sha512").
		MustBuild()

	ecdsaDef := input.NewDefinitionBuilder().
		Label("sig-ecdsa").
		Components(component.New("date"), component.New("content-type")).
		Created(created).
		KeyID("test-key-ecc-p256").
		Algorithm("ecdsa-p256-sha256").
		MustBuild()

	ed25519Def := input.NewDefinitionBuilder().
		Label("sig-ed25519").
		Components(component.Authority(), component.New("content-length")).
		Created(created).
		KeyID("test-key-ed25519").
		Algorithm("ed25519").
		MustBuild()

	hmacDef := input.NewDefinitionBuilder().
		Label("sig-hmac").
		Components(component.New("date"), component.Method()).
		Created(created).
		KeyID("test-shared-secret").
		Algorithm("hmac-sha256").
		MustBuild()

	ctx := component.WithRequestInfoFromHTTP(context.Background(), req)

	// Sign with RSA-PSS
	err = htmsig.SignRequest(ctx, req.Header, input.NewValueBuilder().AddDefinition(rsaDef).MustBuild(), rsaPSSPrivKey)
	require.NoError(t, err)

	// Sign with ECDSA (this will add to existing signatures)
	err = htmsig.SignRequest(ctx, req.Header, input.NewValueBuilder().AddDefinition(ecdsaDef).MustBuild(), ecdsaPrivKey)
	require.NoError(t, err)

	// Sign with Ed25519
	err = htmsig.SignRequest(ctx, req.Header, input.NewValueBuilder().AddDefinition(ed25519Def).MustBuild(), ed25519PrivKey)
	require.NoError(t, err)

	// Sign with HMAC
	err = htmsig.SignRequest(ctx, req.Header, input.NewValueBuilder().AddDefinition(hmacDef).MustBuild(), sharedSecret)
	require.NoError(t, err)

	// Create key resolver for verification
	resolver := &testKeyResolver{
		keys: map[string]any{
			"test-key-rsa-pss":   rsaPSSPrivKey, // For HMAC/symmetric, we can use the same key
			"test-key-ecc-p256":  ecdsaPrivKey,
			"test-key-ed25519":   ed25519PrivKey,
			"test-shared-secret": sharedSecret,
		},
	}

	// Verify all signatures
	ctx = component.WithRequestInfoFromHTTP(context.Background(), req)
	err = htmsig.VerifyRequest(ctx, req.Header, resolver)
	require.NoError(t, err)

	t.Logf("Multiple signature test passed")
	t.Logf("Signature-Input: %s", req.Header.Get("Signature-Input"))
	t.Logf("Signature: %s", req.Header.Get("Signature"))
}

func TestRFC9421_SignatureBaseGeneration(t *testing.T) {
	// Test that we generate the correct signature bases for RFC examples

	testCases := []struct {
		name         string
		setupRequest func() *http.Request
		components   []component.Identifier
		parameters   map[string]any
	}{
		{
			name: "Minimal signature base",
			setupRequest: func() *http.Request {
				return createTestRequest()
			},
			components: []component.Identifier{},
			parameters: map[string]any{
				"created": int64(1618884473),
				"keyid":   "test-key-rsa-pss",
				"nonce":   "b3k2pp5k7z-50gnwp.yemd",
			},
		},
		{
			name: "Authority and content-digest",
			setupRequest: func() *http.Request {
				return createTestRequest()
			},
			components: []component.Identifier{
				component.Authority(),
				component.New("content-digest"),
			},
			parameters: map[string]any{
				"created": int64(1618884473),
				"keyid":   "test-key-rsa-pss",
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			req := tc.setupRequest()

			defBuilder := input.NewDefinitionBuilder().
				Label("test-sig").
				Components(tc.components...)

			if created, ok := tc.parameters["created"]; ok {
				defBuilder = defBuilder.Created(created.(int64))
			}
			if keyid, ok := tc.parameters["keyid"]; ok {
				defBuilder = defBuilder.KeyID(keyid.(string))
			}
			if nonce, ok := tc.parameters["nonce"]; ok {
				defBuilder = defBuilder.Nonce(nonce.(string))
			}

			def := defBuilder.MustBuild()

			// We can't directly test buildSignatureBase as it's not exported,
			// but we can verify that signing and verification work correctly
			// which implicitly tests the signature base generation

			// Use standard RSA key since JWX may not support RSA-PSS PKCS#8 format
			rsaKey, err := parsePrivateKey(testKeyRSAPrivatePEM, "rsa")
			require.NoError(t, err)

			inputValue := input.NewValueBuilder().AddDefinition(def).MustBuild()

			ctx := component.WithRequestInfoFromHTTP(context.Background(), req)
			err = htmsig.SignRequest(ctx, req.Header, inputValue, rsaKey)
			require.NoError(t, err)

			ctx = component.WithRequestInfoFromHTTP(context.Background(), req)
			err = htmsig.VerifyRequest(ctx, req.Header, rsaKey)
			require.NoError(t, err)

			t.Logf("Signature base test passed for: %s", tc.name)
		})
	}
}
